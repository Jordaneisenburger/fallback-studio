import React, { Fragment } from 'react';
import { shallow } from 'enzyme';

import { Items } from '..';

const items = [
    {
        id: '001',
        name: 'Test Product 1',
        small_image: '/test/product/1.png',
        price: {
            regularPrice: {
                amount: {
                    value: 100
                }
            }
        }
    },
    {
        id: '002',
        name: 'Test Product 2',
        small_image: '/test/product/2.png',
        price: {
            regularPrice: {
                amount: {
                    value: 100
                }
            }
        }
    }
];

test('renders a fragment', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);

    expect(wrapper.type()).toEqual(Fragment);
});

test('renders a child for each item', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);

    expect(wrapper.children()).toHaveLength(items.length);
});

test('renders basic children of type `renderItem`', () => {
    const elementType = 'li';
    const props = { items, renderItem: elementType };
    const wrapper = shallow(<Items {...props} />);

    expect.assertions(items.length);
    wrapper.children().forEach(node => {
        expect(
            node
                .dive()
                .dive()
                .type()
        ).toEqual(elementType);
    });
});

test('renders composite children of type `renderItem`', () => {
    const Span = () => <span />;
    const props = { items, renderItem: Span };
    const wrapper = shallow(<Items {...props} />);

    expect.assertions(items.length);
    wrapper.children().forEach(node => {
        expect(node.dive().type()).toEqual(Span);
    });
});

test('passes correct props to each child', () => {
    const elementType = 'li';
    const props = { items, renderItem: elementType };
    const wrapper = shallow(<Items {...props} />);

    wrapper.children().forEach((node, i) => {
        const item = items[i];
        const key = item.id;

        expect(node.key()).toEqual(key);
        expect(node.props()).toMatchObject({
            item,
            itemIndex: i,
            render: props.renderItem,
            hasFocus: false,
            isSelected: false,
            onBlur: wrapper.instance().handleBlur,
            onClick: expect.any(Function),
            onFocus: expect.any(Function)
        });
    });
});

test('uses keys generated by `getItemKey` if provided', () => {
    const identity = x => x;
    const tags = ['a', 'b', 'c'];
    const props = { items: tags, getItemKey: identity };
    const wrapper = shallow(<Items {...props} />);

    wrapper.children().forEach((node, i) => {
        expect(node.key()).toEqual(tags[i]);
    });
});

test('indicates the child at index `cursor` has focus', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);
    const state = { cursor: 1, hasFocus: true };

    wrapper.setState(state);

    wrapper.children().forEach((node, i) => {
        const item = items[i];

        expect(node.props()).toMatchObject({
            item,
            hasFocus: i === state.cursor,
            isSelected: false
        });
    });
});

test('indicates no child has focus if the list is not focused', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);
    const state = { cursor: 1, hasFocus: false };

    wrapper.setState(state);

    wrapper.children().forEach((node, i) => {
        const item = items[i];

        expect(node.props()).toMatchObject({
            item,
            hasFocus: false,
            isSelected: false
        });
    });
});

test('indicates whether a child is selected', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);
    const selection = new Set().add('002');

    wrapper.setState({ selection });

    wrapper.children().forEach((node, i) => {
        const item = items[i];
        const key = item.id;

        expect(node.props()).toMatchObject({
            item,
            hasFocus: false,
            isSelected: selection.has(key)
        });
    });
});

test('updates `hasFocus` on child blur', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);

    wrapper.setState({ hasFocus: true });
    wrapper.childAt(0).simulate('blur');

    expect(wrapper.state('hasFocus')).toBe(false);
});

test('updates `cursor` and `hasFocus` on child focus', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);
    const index = 0;

    wrapper.childAt(index).simulate('focus');

    expect(wrapper.state()).toMatchObject({
        cursor: index,
        hasFocus: true
    });
});

test('updates radio `selection` on child click', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);

    expect(wrapper.state('selection')).toEqual(new Set());

    wrapper.childAt(0).simulate('click');
    expect(wrapper.state('selection')).toEqual(new Set(['001']));

    wrapper.childAt(1).simulate('click');
    expect(wrapper.state('selection')).toEqual(new Set(['002']));

    wrapper.childAt(0).simulate('click');
    expect(wrapper.state('selection')).toEqual(new Set(['001']));
});

test('updates checkbox `selection` on child click', () => {
    const props = { items, selectionModel: 'checkbox' };
    const wrapper = shallow(<Items {...props} />);

    expect(wrapper.state('selection')).toEqual(new Set());

    wrapper.childAt(0).simulate('click');
    expect(wrapper.state('selection')).toEqual(new Set(['001']));

    wrapper.childAt(1).simulate('click');
    expect(wrapper.state('selection')).toEqual(new Set(['001', '002']));

    wrapper.childAt(0).simulate('click');
    expect(wrapper.state('selection')).toEqual(new Set(['002']));
});

test('calls `syncSelection` after updating selection', () => {
    const props = { items };
    const wrapper = shallow(<Items {...props} />);
    const spy = jest.spyOn(wrapper.instance(), 'syncSelection');

    wrapper.childAt(0).simulate('click');

    expect(spy).toHaveBeenCalled();
});

test('calls `onSelectionChange` after updating selection', () => {
    const onSelectionChange = jest.fn();
    const props = { items, onSelectionChange };
    const wrapper = shallow(<Items {...props} />);

    wrapper.childAt(0).simulate('click');

    expect(onSelectionChange).toHaveBeenCalledWith(wrapper.state('selection'));
});

test('memoizes child click handlers', () => {
    const props = { items };
    const instance = shallow(<Items {...props} />).instance();

    expect(instance.getClickHandler(0)).not.toBe(instance.getClickHandler(1));
    expect(instance.getClickHandler(0)).toBe(instance.getClickHandler(0));
});

test('memoizes child focus handlers', () => {
    const props = { items };
    const instance = shallow(<Items {...props} />).instance();

    expect(instance.getFocusHandler(0)).not.toBe(instance.getFocusHandler(1));
    expect(instance.getFocusHandler(0)).toBe(instance.getFocusHandler(0));
});
